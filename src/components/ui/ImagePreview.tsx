import React, { useRef, useEffect, useState, useCallback } from 'react';
import {
  Box,
  Typography,
  CircularProgress,
  Paper,
  Divider,
  ToggleButton,
  Button,
} from '@mui/material';
import { useFaceStore } from '../../stores/faceStore';
import { useStandardizationStore } from '../../stores/standardizationStore';
import { useImageWarping } from '../../hooks/useImageWarping';
import { useFaceDetection } from '../../hooks/useFaceDetection';
import SaveButton from './SaveButton';
import { UnifiedQualitySelector, type UnifiedQualityMode } from './UnifiedQualitySelector';
import type { FaceLandmarks, ImageData } from '../../types/face';

const ImagePreview: React.FC = () => {
  const { 
    originalImage, 
    processedImageUrl,
    isProcessing, 
    setRenderMode,
    setOriginalImage,
    setError,
    setLoading,
    // üöÄ Áµ±Âêà„Éô„Éº„Çπ„Éá„Éº„Çø„Çí‰ΩøÁî®
    currentBaseImageUrl,
    currentBaseLandmarks,
    isStandardized
  } = useFaceStore();
  
  const { 
    standardizedImageUrl
  } = useStandardizationStore();
  
  const originalCanvasRef = useRef<HTMLCanvasElement>(null);
  const fabricCanvasRef = useRef<HTMLCanvasElement>(null);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [canvasSize, setCanvasSize] = useState<{width: number, height: number} | null>(null);
  const [warpingQuality, setWarpingQuality] = useState<'fast' | 'medium' | 'high'>('medium');
  const [showLandmarks, setShowLandmarks] = useState<boolean>(true);
  const [qualityMode, setQualityMode] = useState<UnifiedQualityMode>('balanced');
  
  const { initializeCanvas } = useImageWarping(warpingQuality);
  const { detectFace, initializeModels, isLoadingModels } = useFaceDetection();

  // Áµ±ÂêàÂìÅË≥™Ë®≠ÂÆö„ÅÆÂ§âÊõ¥„Éè„É≥„Éâ„É©„Éº
  const handleQualityModeChange = (mode: UnifiedQualityMode) => {
    setQualityMode(mode);
  };

  const handleWarpingQualityChange = (quality: 'fast' | 'medium' | 'high') => {
    setWarpingQuality(quality);
  };

  const handleRenderModeChange = (mode: 'forward' | 'hybrid' | 'backward') => {
    setRenderMode(mode);
  };

  // Êñ∞„Åó„ÅÑÁîªÂÉè„ÇíÈñã„Åè„Éè„É≥„Éâ„É©„Éº
  const handleOpenNewImage = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/jpeg,image/png,image/jpg';
    input.onchange = async (event) => {
      const file = (event.target as HTMLInputElement).files?.[0];
      if (!file) return;

      try {
        setLoading(true);
        setError(null);

        // „Éï„Ç°„Ç§„É´Ê§úË®º
        const MAX_FILE_SIZE = 8 * 1024 * 1024; // 8MB
        const SUPPORTED_FORMATS = ['image/jpeg', 'image/png', 'image/jpg'];
        
        if (!SUPPORTED_FORMATS.includes(file.type)) {
          throw new Error('„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Åß„Åô„ÄÇJPEG„Åæ„Åü„ÅØPNG„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }
        
        if (file.size > MAX_FILE_SIZE) {
          throw new Error('„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅåÂ§ß„Åç„Åô„Åé„Åæ„Åô„ÄÇ8MB‰ª•‰∏ã„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }

        // ÁîªÂÉè„Éá„Éº„Çø„Çí‰ΩúÊàê
        const imageData: ImageData = await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            resolve({
              file,
              url: URL.createObjectURL(file),
              width: img.naturalWidth,
              height: img.naturalHeight
            });
          };
          img.onerror = () => reject(new Error('ÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ'));
          img.src = URL.createObjectURL(file);
        });

        setOriginalImage(imageData, file.name);

        // È°îÊ§úÂá∫„ÇíÂÆüË°å
        const img = new Image();
        img.onload = async () => {
          try {
            await initializeModels();
            await detectFace(img);
          } catch (faceError) {
            const errorMessage = faceError instanceof Error ? faceError.message : 'È°îÊ§úÂá∫„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ';
            setError(errorMessage);
          }
        };
        img.src = imageData.url;

      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'ÁîªÂÉè„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ';
        setError(errorMessage);
      } finally {
        setLoading(false);
      }
    };
    input.click();
  };

  // originalImage„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÊôÇ„Å´imageLoaded„Çí„É™„Çª„ÉÉ„Éà
  useEffect(() => {
    console.log('üñºÔ∏è originalImage changed:', originalImage ? '„ÅÇ„Çä' : '„Å™„Åó');
    setImageLoaded(false);
  }, [originalImage]);

  // Fabric.js Canvas „ÅÆÂàùÊúüÂåñÔºàcanvasSize„ÅåÁ¢∫ÂÆö„Åó„Å¶„Åã„ÇâÔºâ
  useEffect(() => {
    console.log('üé® Fabric.js Canvas ÂàùÊúüÂåñ„ÉÅ„Çß„ÉÉ„ÇØ:', {
      hasFabricCanvas: !!fabricCanvasRef.current,
      hasOriginalImage: !!originalImage,
      hasCanvasSize: !!canvasSize,
      canvasSize
    });

    if (fabricCanvasRef.current && originalImage && canvasSize) {
      console.log('‚úÖ Fabric.js Canvas ÂàùÊúüÂåñÂÆüË°å - „Çµ„Ç§„Ç∫:', canvasSize);
      initializeCanvas(fabricCanvasRef.current, canvasSize.width, canvasSize.height);
    } else {
      console.log('‚ùå Fabric.js Canvas ÂàùÊúüÂåñ„Çπ„Ç≠„ÉÉ„Éó - Êù°‰ª∂‰∏çË∂≥');
    }
  }, [originalImage, canvasSize, initializeCanvas]);

  // Canvas „Çµ„Ç§„Ç∫Ë®àÁÆó„ÅÆÂÖ±ÈÄöÈñ¢Êï∞Ôºà„Ç∑„É≥„Éó„É´ÁâàÔºâ
  const calculateCanvasSize = useCallback((container: HTMLElement | null, imageWidth: number, imageHeight: number, canvasType: string) => {
    if (!container) {
      console.warn(`‚ö†Ô∏è ${canvasType}: Container not found, using default size`);
      return { width: 400, height: 400, scale: 1 };
    }
    
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    console.log(`üìê ${canvasType} - Container size:`, { containerWidth, containerHeight });
    
    // „Éë„Éá„Ç£„É≥„Ç∞„ÇíËÄÉÊÖÆÔºàÂ∑¶Âè≥ÂêàË®à20pxÔºâ
    const availableWidth = containerWidth - 20;
    const availableHeight = containerHeight - 20;
    
    // „Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„Çí‰øùÊåÅ„Åó„Å™„Åå„Çâ„Çπ„Ç±„Éº„É´„ÇíË®àÁÆó
    const scale = Math.min(availableWidth / imageWidth, availableHeight / imageHeight);
    
    const width = Math.floor(imageWidth * scale);
    const height = Math.floor(imageHeight * scale);
    
    const result = { width, height, scale };
    
    console.log(`üìê ${canvasType} - Size calculation:`, {
      image: { width: imageWidth, height: imageHeight },
      available: { width: availableWidth, height: availableHeight },
      result
    });
    
    return result;
  }, []);

  // üöÄ Áµ±Âêà„Éô„Éº„ÇπÁîªÂÉè„Çí Canvas „Å´ÊèèÁîª
  useEffect(() => {
    if (!currentBaseImageUrl || !originalCanvasRef.current) {
      console.log('‚ö†Ô∏è „Éô„Éº„ÇπÁîªÂÉè„Åæ„Åü„ÅØCanvas„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
      return;
    }

    const canvas = originalCanvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('‚ùå Canvas context „ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì');
      return;
    }

    console.log('üé® Áµ±Âêà„Éô„Éº„ÇπÁîªÂÉèÊèèÁîªÈñãÂßã:', { 
      url: currentBaseImageUrl,
      isStandardized 
    });
    const img = new Image();
    
    img.onload = () => {
      console.log('‚úÖ ÁîªÂÉèË™≠„ÅøËæº„ÅøÊàêÂäü:', img.width, 'x', img.height);
      
      // Canvas „Çµ„Ç§„Ç∫„ÇíË®àÁÆó
      const container = canvas.parentElement;
      const { width, height, scale } = calculateCanvasSize(container, img.width, img.height, 'ÂÖÉÁîªÂÉèCanvas');
      
      // Canvas „Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
      canvas.width = width;
      canvas.height = height;
      
      // Canvas„Çµ„Ç§„Ç∫„Çí‰øùÂ≠òÔºàÁ∑®ÈõÜÂæåCanvas„Å®ÂêåÊúü„Åô„Çã„Åü„ÇÅÔºâ
      setCanvasSize({ width, height });
      
      console.log(`üé® ÂÖÉÁîªÂÉèCanvasË®≠ÂÆö: ${width}x${height}, scale: ${scale}`);
      
      // ÁîªÂÉè„ÇíÊèèÁîª
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(img, 0, 0, width, height);
      console.log('‚úÖ Canvas „Å´ÁîªÂÉè„ÇíÊèèÁîª„Åó„Åæ„Åó„Åü');
      
      // È°îÊ§úÂá∫ÁµêÊûú„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅÁâπÂæ¥ÁÇπ„ÇíÊèèÁîªÔºàË°®Á§∫„Éï„É©„Ç∞„Åå„Ç™„É≥„ÅÆÊôÇ„ÅÆ„ÅøÔºâ
      if (currentBaseLandmarks && showLandmarks) {
        console.log('üéØ Áµ±Âêà„Éô„Éº„Çπ„É©„É≥„Éâ„Éû„Éº„ÇØ„ÇíÊèèÁîª:', { isStandardized });
        drawLandmarks(ctx, currentBaseLandmarks, scale);
      }
      
      setImageLoaded(true);
    };
    
    img.onerror = (error) => {
      console.error('‚ùå ÁîªÂÉèË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
      setImageLoaded(false);
    };
    
    img.src = currentBaseImageUrl;
  }, [currentBaseImageUrl, currentBaseLandmarks, showLandmarks, calculateCanvasSize, isStandardized]);

  // ÈáçË§áÂá¶ÁêÜ„ÇíÂâäÈô§ - useImageWarping„Éï„ÉÉ„ÇØ„Åß„ÉØ„Éº„Éî„É≥„Ç∞Âá¶ÁêÜ„Çí‰∏ÄÊú¨Âåñ
  // „Åì„ÅÆuseEffect„ÅØÂâäÈô§„Åï„Çå„ÄÅ„Åô„Åπ„Å¶„ÅÆ„ÉØ„Éº„Éî„É≥„Ç∞Âá¶ÁêÜ„ÅØuseImageWarping„Éï„ÉÉ„ÇØ„ÅßÁÆ°ÁêÜ„Åï„Çå„Åæ„Åô
  
  // „Ç≥„É°„É≥„Éà„Ç¢„Ç¶„Éà„Åó„ÅüÈáçË§áÂá¶ÁêÜ:
  // - „Éë„É©„É°„Éº„ÇøÂ§âÊõ¥ÊôÇ„ÅÆ„ÉØ„Éº„Éî„É≥„Ç∞Âá¶ÁêÜ
  // - „Éá„Éê„Ç¶„É≥„ÇπÂá¶ÁêÜ
  // - ÂìÅË≥™Âà•„ÅÆ„ÉØ„Éº„Éî„É≥„Ç∞Âá¶ÁêÜ
  // „Åì„Çå„Çâ„ÅØ„Åô„Åπ„Å¶useImageWarping.ts„ÅßÂÆüË°å„Åï„Çå„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ‰∏çË¶Å„Åß„Åô

  // Á∑®ÈõÜÂæåÁîªÂÉè„ÅÆË°®Á§∫Ôºà„ÉØ„Éº„Éî„É≥„Ç∞ÁµêÊûú„Åæ„Åü„ÅØÂÖÉÁîªÂÉèÔºâ
  useEffect(() => {
    if (fabricCanvasRef.current && canvasSize) {
      const canvas = fabricCanvasRef.current;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      
      // „ÉØ„Éº„Éî„É≥„Ç∞ÁµêÊûú„ÄÅÊ®ôÊ∫ñÂåñÁµêÊûú„ÄÅÂÖÉÁîªÂÉè„ÅÆÈ†Ü„ÅßË°®Á§∫ÔºàÊúÄÊñ∞Âá¶ÁêÜÁµêÊûú„ÇíÂÑ™ÂÖàÔºâ
      const imageUrl = processedImageUrl || standardizedImageUrl || (originalImage?.url);
      
      if (imageUrl) {
        const displayType = processedImageUrl ? '(„ÉØ„Éº„Éî„É≥„Ç∞Ê∏à„Åø)' : standardizedImageUrl ? '(Ê®ôÊ∫ñÂåñÊ∏à„Åø)' : '(ÂÖÉÁîªÂÉè)';
        console.log(`üîÑ Á∑®ÈõÜÂæåCanvasË°®Á§∫: ${canvasSize.width}x${canvasSize.height}`, displayType);
        
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);
          ctx.drawImage(img, 0, 0, canvasSize.width, canvasSize.height);
          console.log('‚úÖ Á∑®ÈõÜÂæåCanvas„Å´ÁîªÂÉè„ÇíÊèèÁîª');
        };
        img.onerror = (error) => {
          console.error('‚ùå Á∑®ÈõÜÂæåÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
          // „Ç®„É©„ÉºÊôÇ„ÅØÂÖÉÁîªÂÉè„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
          if (originalImage && imageUrl !== originalImage.url) {
            img.src = originalImage.url;
          }
        };
        img.src = imageUrl;
      }
    }
  }, [canvasSize, originalImage, processedImageUrl, standardizedImageUrl]);

  // ÁâπÂæ¥ÁÇπ„ÇíÊèèÁîª„Åô„ÇãÈñ¢Êï∞
  const drawLandmarks = (
    ctx: CanvasRenderingContext2D,
    landmarks: FaceLandmarks,
    scale: number
  ) => {
    if (!landmarks) return;

    // ÁõÆ„ÅÆÁâπÂæ¥ÁÇπ„ÇíÊèèÁîª
    const drawPoints = (points: Array<{x: number, y: number}>, color: string) => {
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;

      points.forEach((point, index) => {
        const x = point.x * scale;
        const y = point.y * scale;
        
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, 2 * Math.PI);
        ctx.fill();
        
        // Áï™Âè∑„ÇíË°®Á§∫Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
        ctx.fillText(`${index}`, x + 3, y - 3);
      });
    };

    // ÂêÑ„Éë„Éº„ÉÑ„ÇíÁï∞„Å™„ÇãËâ≤„ÅßÊèèÁîª
    if (landmarks.leftEye) drawPoints(landmarks.leftEye, '#FF0000');      // Ëµ§
    if (landmarks.rightEye) drawPoints(landmarks.rightEye, '#00FF00');    // Á∑ë
    if (landmarks.mouth) drawPoints(landmarks.mouth, '#0000FF');          // Èùí
    if (landmarks.nose) drawPoints(landmarks.nose, '#FF00FF');            // „Éû„Çº„É≥„Çø
    if (landmarks.jawline) drawPoints(landmarks.jawline, '#FFFF00');      // ÈªÑ
    if (landmarks.leftEyebrow) drawPoints(landmarks.leftEyebrow, '#FF8800'); // „Ç™„É¨„É≥„Ç∏
    if (landmarks.rightEyebrow) drawPoints(landmarks.rightEyebrow, '#8800FF'); // Á¥´
  };

  if (!originalImage) {
    return (
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          height: '100%',
          minHeight: 300,
        }}
      >
        <Typography variant="body1" color="text.secondary">
          ÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ
        </Typography>
      </Box>
    );
  }

  return (
    <Box 
      sx={{ 
        display: 'flex', 
        gap: 2, 
        height: '100%',
        flexDirection: { xs: 'column', md: 'row' },
        position: 'relative'
      }}
    >
        {/* ÂÖÉÁîªÂÉè */}
        <Paper elevation={2} sx={{ p: 2, flex: 1, display: 'flex', flexDirection: 'column', height: '100%' }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Typography variant="subtitle1" sx={{ flexShrink: 0 }}>
                {isStandardized ? '„Éô„Éº„ÇπÁîªÂÉè' : 'ÂÖÉÁîªÂÉè'}
              </Typography>
              {isStandardized && (
                <Typography 
                  variant="caption" 
                  sx={{ 
                    bgcolor: 'primary.main', 
                    color: 'white', 
                    px: 1, 
                    py: 0.25, 
                    borderRadius: 1,
                    fontSize: '0.65rem'
                  }}
                >
                  Ê®ôÊ∫ñÂåñÊ∏à„Åø
                </Typography>
              )}
            </Box>
            
            <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
              <Button
                variant="outlined"
                size="small"
                onClick={handleOpenNewImage}
                sx={{ 
                  py: 0.5, 
                  px: 1, 
                  fontSize: '0.75rem',
                  minWidth: 'auto',
                }}
              >
                üìÅ Êñ∞„Åó„ÅÑÁîªÂÉè
              </Button>
              
              <ToggleButton
                value="landmarks"
                selected={showLandmarks}
                onChange={() => setShowLandmarks(!showLandmarks)}
                size="small"
                sx={{ 
                  py: 0.5, 
                  px: 1, 
                  fontSize: '0.75rem',
                  minWidth: 'auto',
                  '&.Mui-selected': {
                    backgroundColor: 'primary.main',
                    color: 'primary.contrastText',
                    '&:hover': {
                      backgroundColor: 'primary.dark',
                    },
                  },
                }}
              >
                üëÅÔ∏è ÁâπÂæ¥ÁÇπ
              </ToggleButton>
            </Box>
          </Box>
          
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              flex: 1,
              position: 'relative',
              overflow: 'hidden',
            }}
          >
              <canvas
                ref={originalCanvasRef}
                style={{
                  border: '1px solid #ddd',
                  display: imageLoaded ? 'block' : 'none',
                }}
              />
              {!imageLoaded && (
                <CircularProgress sx={{ position: 'absolute' }} />
              )}
          </Box>
        </Paper>

        {/* Âå∫Âàá„ÇäÁ∑ö */}
        <Divider 
          orientation="vertical" 
          flexItem 
          sx={{ display: { xs: 'none', md: 'block' } }}
        />
        <Divider 
          orientation="horizontal" 
          flexItem 
          sx={{ display: { xs: 'block', md: 'none' } }}
        />

        {/* Á∑®ÈõÜÂæåÁîªÂÉè */}
        <Paper elevation={2} sx={{ p: 2, flex: 1, display: 'flex', flexDirection: 'column', height: '100%' }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
            <Typography variant="subtitle1" sx={{ flexShrink: 0 }}>
              Á∑®ÈõÜÂæå
            </Typography>
            
            <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
              {/* Áµ±ÂêàÂìÅË≥™Ë®≠ÂÆö */}
              <UnifiedQualitySelector
                value={qualityMode}
                onChange={handleQualityModeChange}
                onWarpingQualityChange={handleWarpingQualityChange}
                onRenderModeChange={handleRenderModeChange}
              />
              
              {/* ‰øùÂ≠ò„Éú„Çø„É≥ */}
              {processedImageUrl && (
                <SaveButton canvasRef={fabricCanvasRef} />
              )}
            </Box>
          </Box>
          
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              flex: 1,
              position: 'relative',
              overflow: 'hidden',
            }}
          >
              <canvas
                ref={fabricCanvasRef}
                style={{
                  border: '1px solid #ddd',
                  display: originalImage && !isProcessing ? 'block' : 'none',
                }}
              />
              {isProcessing && (
                <Box sx={{ textAlign: 'center', position: 'absolute' }}>
                  <CircularProgress sx={{ mb: 2 }} />
                  <Typography variant="body2" color="text.secondary">
                    Âá¶ÁêÜ‰∏≠...
                  </Typography>
                  {isLoadingModels && (
                    <Typography variant="caption" color="primary.main" sx={{ mt: 1, display: 'block' }}>
                      ÂàùÂõû„ÅØÈ°îÊ§úÂá∫„É¢„Éá„É´„ÅÆË™≠„ÅøËæº„Åø„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô
                    </Typography>
                  )}
                </Box>
              )}
              {!originalImage && !isProcessing && (
                <Typography variant="body2" color="text.secondary">
                  „Éë„É©„É°„Éº„Çø„ÇíË™øÊï¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ
                </Typography>
              )}
          </Box>
        </Paper>

    </Box>
  );
};

export default ImagePreview; 
# 注視方向コントロール機能の問題分析レポート

## 1. はじめに

本レポートは、顔パーツ操作アプリケーションにおける「注視方向コントロール（虹彩操作）」機能の実装時に発生している画像描画の破綻問題について、その原因を分析し、考えられる解決策を提示するものです。

## 2. 問題の概要

ユーザーが虹彩コントロールのスライダーを少しでも操作すると、プレビュー画像全体が著しく乱れる現象が発生しています。この問題は、虹彩のオフセットが0でない場合にのみ発生し、メッシュ変形処理の段階で根本的な不整合が起きていることを示唆しています。

## 3. 根本原因の特定

調査の結果、問題の根本原因は**メッシュ変形の基点となるランドマークの点数が、変形前後で一致していないこと**にあります。

メッシュ変形アルゴリズムは、変形前の頂点群と変形後の頂点群が同数であり、かつインデックスが完全に対応していることを前提としています。しかし、現在の実装ではこの前提が崩れてしまっています。

### 3.1. なぜランドマークの点数が変動するのか？

ランドマーク数の変動は、`src/features/iris-control/denseEyeLandmarks.ts` 内の `generateTransitionPoints` 関数に起因します。

この関数は、虹彩とまぶたの間を埋める「遷移点」を生成する役割を担っていますが、以下の2つの要因により、実行のたびに生成される点の数が変動します。

1.  **ランダム性を含む間引き処理**:
    以下のコード箇所で、点の配置に `Math.random()` が使用されています。これにより、同じ入力パラメータであっても、呼び出されるたびに異なる数の遷移点が生成されます。
    ```typescript
    // src/features/iris-control/denseEyeLandmarks.ts -> generateTransitionPoints
    if (options.adaptive) {
      const normalizedDistance = distanceToIris / (irisRadius * 2);
      const adaptiveSpacing = baseSpacing * Math.max(0.5, normalizedDistance);
      
      // 間引き判定（ランダム性を含む）
      if (Math.random() > (baseSpacing / adaptiveSpacing)) continue;
    }
    ```

2.  **不安定な領域判定**:
    遷移点の候補が目の領域内にあるかを `isPointInEyeRegion` 関数で判定しています。目の傾きや形状がわずかに変わるだけで、グリッド上の点が領域内に入るかどうかの判定結果が変わり、最終的な点の総数が変動する可能性があります。

### 3.2. 問題発生の連鎖プロセス

1.  **ランドマーク生成**: `denseEyeLandmarks.ts` が、上記の不安定なロジックにより、**可変長**の密ランドマークを生成します。
2.  **頂点リスト変換**: `meshDeformation.ts` 内の `landmarksToPoints` 関数が、メッシュ変形のためにランドマークを単一の頂点リストに変換します。この処理は、変形前と変形後のランドマークに対してそれぞれ呼び出されます。
3.  **点数の不一致**: 変形前（虹彩移動なし）と変形後（虹彩移動あり）で `landmarksToPoints` が返す頂点リストの**要素数が異なってしまいます**。（例：変形前 200点、変形後 198点）
4.  **三角形分割**: 三角形メッシュは、変形前の頂点リスト（200点）を基準に生成されます。
5.  **メッシュ描画の破綻**: 描画処理では、変形前の三角形と変形後の三角形が1対1で対応していることを期待します。しかし、変形後の頂点リストは点数が異なる（198点）ため、三角形を構成する頂点のインデックスがずれてしまい、意図しない形状の三角形が描画され、画像が破綻します。

## 4. 関連する主要なコード箇所

-   `src/features/iris-control/denseEyeLandmarks.ts`:
    -   `generateTransitionPoints`: 点数変動の直接的な原因。
-   `src/features/image-warping/forwardMapping/meshDeformation.ts`:
    -   `landmarksToPoints`: 変形前後で異なる点数のリストを生成してしまう箇所。
    -   `createMeshDeformation`: 変形前後で点数が異なるデータを受け取り、破綻したメッシュ情報を生成する箇所。

## 5. 推奨される解決策

この問題を解決するには、**いかなる場合でも変形前後のランドマークの点数が完全に一致する状態**を保証する必要があります。以下に具体的な解決策を提案します。

### 解決策A: 密ランドマークの点数を固定化する（最も推奨）

`denseEyeLandmarks.ts` を修正し、常に固定数のランドマークを生成するようにロジックを安定させます。

**具体的な実装方針:**

1.  **`generateTransitionPoints` の修正**:
    -   ランダム性 (`Math.random()`) を排除します。
    -   グリッドベースのサンプリングではなく、まぶたのラインと虹彩の円周から一定数の点を補間するような、決定論的な手法に変更します。例えば、同心円状または放射状に点を配置する方法が考えられます。
2.  **各層の点数を固定**:
    -   `generateDenseEyeLandmarks` 関数全体で、生成される各層（まぶた、虹彩、遷移領域）の点数を固定値にします。
    -   不足分は補間によって生成し、余剰分は間引く、あるいはそもそもロジックとして固定数を返すように設計します。
3.  **バリデーションの追加**:
    -   デバッグ目的で、生成されたランドマークの総数をチェックし、期待値と異なる場合に警告を出すアサーションを追加します。

**メリット**:
-   虹彩コントロールの品質を維持したまま、システムの安定性を確保できる。
-   問題の根本原因を解決する、最もクリーンなアプローチ。

**デメリット**:
-   遷移点の配置ロジックを再設計する必要がある。

### 解決策B: 既存の点を移動させるアプローチ

新しい点を生成するのではなく、既存の標準ランドマーク（68点）と、それらを補間して生成した固定数の追加点のみを変形対象とします。

**具体的な実装方針:**

-   虹彩の移動は、虹彩周辺の（あらかじめ決められた）固定数の点群を、ベクトル計算によって平行移動させることで表現します。
-   つまり、`generateDenseEyeLandmarks` で行うような複雑な再生成を行わず、常に同じ構造のランドマークセットを操作対象とします。

**メリット**:
-   実装が比較的単純で、安定性が高い。

**デメリット**:
-   虹彩の動きやまぶたとのインタラクションの自然さが、解決策Aに劣る可能性がある。

## 6. まとめと次のステップ

現状の問題は、密ランドマークの生成ロジックが不安定であることに起因しています。推奨される次のステップは、**解決策A** の方針に基づき、`denseEyeLandmarks.ts` を修正して、常に固定数のランドマークを返すように改修することです。これにより、メッシュ変形処理の前提条件が満たされ、安定した注視方向コントロールが可能になります。

## 7. 俯瞰的レビューと追加の改善提案

虹彩コントロール機能の直接的な問題解決とは別に、プロジェクト全体のコード品質と保守性を向上させるための追加の提案を以下に記します。これらは直ちに修正が必要なバグではありませんが、将来的な開発効率を高めるためのリファクタリングとして有効です。

### 7.1. グローバル定数管理の改善 (`src/types/face.ts`)

**現状:**
顔パーツの操作パラメータ制限値（`PARAM_LIMITS`）が、型定義ファイルである `src/types/face.ts` 内に直接記述されています。

**問題点:**
型定義とアプリケーションの具体的な設定値が混在しており、「関心の分離」の原則に反しています。

**提案:**
- `src/constants/` ディレクトリを新設します。
- `src/constants/parameterLimits.ts` のような設定値専用のファイルを作成し、`PARAM_LIMITS` 定数をそこへ移動させます。
- `src/types/face.ts` は純粋な型定義に専念させ、UIコンポーネント等は新しい定数ファイルから値をインポートするように変更します。

**メリット:**
- **保守性の向上**: パラメータ値を変更する際に、修正箇所が明確になります。
- **関心の分離**: 型と定数が分離され、コードの見通しが良くなります。

### 7.2. 状態管理ロジックの責務分離 (`src/stores/faceStore.ts`)

**現状:**
Zustandストア (`faceStore.ts`) に、状態そのものだけでなく、状態を取得するための補助的なユーティリティ関数（例: `getPartParams`)などが含まれており、ストアの責務が肥大化しています。

**提案:**
- `getPartParams` のような、特定の箇所でしか使われない補助ロジックは、ストアから分離し、カスタムフックや `src/utils/` 配下のユーティリティ関数として切り出すことを検討します。
- 複雑な初期状態オブジェクト (`initialFaceParams`) も、`src/constants/` 配下の別ファイルに分離することで、ストア本体の可読性を高めます。

**メリット:**
- **責務の明確化**: ストアが状態管理という本来の役割に集中できます。
- **テストの容易性**: 分離された純粋関数は単体テストが容易になります。

### 7.3. 命名規則の統一

**現状:**
`src/features/` ディレクトリ配下で、ファイル/ディレクトリの命名規則に軽微な揺らぎが見られます。（例: `image-warping` ディレクトリと `adaptiveWarping.ts` ファイル）

**提案:**
- プロジェクトとして、フィーチャー関連のファイル命名規則（例: `[feature-name].feature.ts`, `[feature-name].utils.ts` など）をドキュメントに明記し、統一を図ります。

**メリット:**
- **一貫性の確保**: プロジェクトが拡大しても、ファイル構造の予測可能性が高まります。

これらの改善は、虹彩コントロールの問題解決後に着手することを推奨します。 